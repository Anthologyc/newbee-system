package main

import (
	"fmt"
	"myapp/models"
	"net/http"
	"os"
	"strconv"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/golang-jwt/jwt/v5"
	"golang.org/x/crypto/bcrypt"
	"gorm.io/driver/mysql"
	"gorm.io/gorm"
)

var db *gorm.DB
var jwtSecret = []byte("your_super_secret_key") // ç”Ÿäº§ç¯å¢ƒè¯·æ”¾å…¥ç¯å¢ƒå˜é‡

// åˆå§‹åŒ–æ•°æ®åº“
func initDB() {
	dsn := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?charset=utf8mb4&parseTime=True&loc=Local",
		os.Getenv("DB_USER"), os.Getenv("DB_PASSWORD"), os.Getenv("DB_HOST"), os.Getenv("DB_PORT"), os.Getenv("DB_NAME"),
	)
	var err error
	db, err = gorm.Open(mysql.Open(dsn), &gorm.Config{})
	if err != nil {
		panic("âŒ Failed to connect to database")
	}
	
	// è‡ªåŠ¨è¿ç§»è¡¨ç»“æ„
	db.AutoMigrate(&models.User{}, &models.Question{}, &models.Announcement{}, &models.Mistake{})
	fmt.Println("âœ… Database migrated: Users, Questions & Announcements")
}

// æ³¨å†Œæ¥å£
// æ³¨å†Œæ¥å£
func register(c *gin.Context) {
	// ğŸš€ ä¿®æ”¹ï¼šä½¿ç”¨ä¸´æ—¶ç»“æ„ä½“æ¥æ”¶å‚æ•°ï¼Œç¡®ä¿èƒ½è¯»åˆ° password
	var input struct {
		Username string `json:"username" binding:"required"`
		Password string `json:"password" binding:"required"`
		Role     string `json:"role"`
	}

	if err := c.ShouldBindJSON(&input); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// å¯†ç åŠ å¯†
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(input.Password), bcrypt.DefaultCost)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to hash password"})
		return
	}

	// æ„å»º User æ¨¡å‹å†™å…¥æ•°æ®åº“
	user := models.User{
		Username: input.Username,
		Password: string(hashedPassword), // å­˜å…¥å“ˆå¸Œå€¼
		Role:     input.Role,
	}

	// é»˜è®¤è§’è‰²ä¸º user
	if user.Role == "" {
		user.Role = "user"
	}

	if err := db.Create(&user).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "User already exists"})
		return
	}
	
	c.JSON(http.StatusOK, gin.H{
		"message": "Registration successful", 
		"role": user.Role,
	})
}

// ç™»å½•æ¥å£
func login(c *gin.Context) {
	// å®šä¹‰ä¸€ä¸ªä¸´æ—¶ç»“æ„ä½“ç”¨æ¥æ¥æ”¶å‰ç«¯å‚æ•°ï¼Œé¿å…ç»‘å®š models.User æ—¶å‡ºç°é—®é¢˜
	var input struct {
		Username string `json:"username" binding:"required"`
		Password string `json:"password" binding:"required"`
	}

	if err := c.ShouldBindJSON(&input); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Missing username or password"})
		return
	}

	var user models.User
	// 1. æŸ¥æ‰¾ç”¨æˆ·
	if err := db.Where("username = ?", input.Username).First(&user).Error; err != nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials (User not found)"})
		return
	}

	// 2. éªŒè¯å¯†ç 
	// input.Password æ˜¯å‰ç«¯ä¼ æ¥çš„æ˜æ–‡ "123456"
	// user.Password æ˜¯æ•°æ®åº“é‡Œçš„å“ˆå¸Œ "$2a$10$..."
	err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(input.Password))
	if err != nil {
		// ğŸ”´ æ ¸å¿ƒï¼šå¯†ç é”™è¯¯å¿…é¡»è¿”å› 401 å¹¶ return
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials (Password mismatch)"})
		return
	}

	// 3. ç”Ÿæˆ JWT Token
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
		"user_id": user.ID,
		"role":    user.Role,
		"exp":     time.Now().Add(time.Hour * 24).Unix(),
	})
	tokenString, _ := token.SignedString(jwtSecret)

	// 4. è¿”å›ç»“æœ
	c.JSON(http.StatusOK, gin.H{
		"token": tokenString,
		"role":  user.Role,
		"username": user.Username,
	})
}

// --- å…¶ä»–ä¸šåŠ¡æ¥å£ä¿æŒä¸å˜ï¼Œç¯‡å¹…åŸå› çœç•¥ï¼Œç›´æ¥æŠŠä½ ä¹‹å‰çš„ createQuestion ç­‰å‡½æ•°ä¿ç•™å³å¯ ---
// ä¸ºäº†å®Œæ•´æ€§ï¼Œæˆ‘æŠŠä¹‹å‰çš„ main å‡½æ•°æ¡†æ¶å†™å‡ºæ¥ï¼Œä½ å¯ä»¥æŠŠä½ å†™å¥½çš„ä¸šåŠ¡å‡½æ•°ç²˜è´´å›æ¥ï¼Œ
// æˆ–è€…å¦‚æœä½ éœ€è¦æˆ‘æä¾›å®Œæ•´çš„ä¸€åƒè¡Œæ–‡ä»¶ä¹Ÿå¯ä»¥ï¼Œä½†ç›®å‰å…³é”®æ˜¯ login å’Œ registerã€‚

// ... æŠŠä½ åŸæ¥çš„ createQuestion, getQuestions ... ç­‰å‡½æ•°æ”¾åœ¨è¿™é‡Œ ...
// åˆ›å»ºé¢˜ç›®
func createQuestion(c *gin.Context) {
	var input models.Question
	if err := c.ShouldBindJSON(&input); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	if err := db.Create(&input).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create question"})
		return
	}
	c.JSON(http.StatusOK, input)
}

func getQuestions(c *gin.Context) {
	var questions []models.Question
	category := c.Query("category")
	qType := c.Query("type")
	query := db.Model(&models.Question{})
	if category != "" {
		query = query.Where("category = ?", category)
	}
	if qType != "" {
		query = query.Where("question_type = ?", qType)
	}
	query.Order("created_at desc").Limit(100).Find(&questions)
	c.JSON(http.StatusOK, gin.H{"data": questions, "total": len(questions)})
}

func getQuestion(c *gin.Context) {
	id := c.Param("id")
	var question models.Question
	if err := db.First(&question, id).Error; err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Question not found"})
		return
	}
	c.JSON(http.StatusOK, question)
}

func updateQuestion(c *gin.Context) {
	id := c.Param("id")
	var question models.Question
	if err := db.First(&question, id).Error; err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Question not found"})
		return
	}
	var input models.Question
	if err := c.ShouldBindJSON(&input); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	db.Model(&question).Updates(input)
	c.JSON(http.StatusOK, question)
}

func deleteQuestion(c *gin.Context) {
	id := c.Param("id")
	if err := db.Delete(&models.Question{}, id).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete"})
		return
	}
	c.JSON(http.StatusOK, gin.H{"message": "Deleted successfully"})
}

func createAnnouncement(c *gin.Context) {
	var input models.Announcement
	if err := c.ShouldBindJSON(&input); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	input.Status = true
	if err := db.Create(&input).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create announcement"})
		return
	}
	c.JSON(http.StatusOK, input)
}

func getAnnouncements(c *gin.Context) {
	var list []models.Announcement
	db.Order("created_at desc").Limit(50).Find(&list)
	c.JSON(http.StatusOK, gin.H{"data": list})
}

func deleteAnnouncement(c *gin.Context) {
	id := c.Param("id")
	if err := db.Delete(&models.Announcement{}, id).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete"})
		return
	}
	c.JSON(http.StatusOK, gin.H{"message": "Deleted successfully"})
}

func getDashboardStats(c *gin.Context) {
	var userCount int64
	var questionCount int64
	var latestAnnouncement models.Announcement
	db.Model(&models.User{}).Count(&userCount)
	db.Model(&models.Question{}).Count(&questionCount)
	db.Order("created_at desc").First(&latestAnnouncement)
	c.JSON(http.StatusOK, gin.H{
		"user_count":     userCount,
		"question_count": questionCount,
		"announcement":   latestAnnouncement,
	})
}

func getUsers(c *gin.Context) {
	var users []models.User
	db.Order("created_at desc").Limit(100).Find(&users)
	c.JSON(http.StatusOK, gin.H{"data": users})
}

func deleteUser(c *gin.Context) {
	id := c.Param("id")
	if err := db.Delete(&models.User{}, id).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete user"})
		return
	}
	c.JSON(http.StatusOK, gin.H{"message": "User deleted successfully"})
}

// ğŸš€ ä¿®æ”¹ï¼šéšæœºè·å–é¢˜ç›® (æ”¯æŒç­›é€‰)
func getRandomQuestions(c *gin.Context) {
	countStr := c.DefaultQuery("count", "100")
	category := c.Query("category")
	qType := c.Query("type")

	count, _ := strconv.Atoi(countStr)
	
	var questions []models.Question
	
	// æ„å»ºæŸ¥è¯¢
	query := db.Model(&models.Question{})
	
	if category != "" {
		query = query.Where("category = ?", category)
	}
	if qType != "" {
		query = query.Where("question_type = ?", qType)
	}
	
	// MySQL éšæœºæ’åº
	query.Order("RAND()").Limit(count).Find(&questions)
	
	c.JSON(http.StatusOK, gin.H{"data": questions})
}

// ğŸš€ æ–°å¢ï¼šé¡ºåºè·å–é¢˜ç›® (æŒ‰ ID æ’åº)
func getSequentialQuestions(c *gin.Context) {
	// ç®€å•èµ·è§ï¼Œå…ˆå–å‰ 100 é¢˜ã€‚å¦‚æœé¢˜åº“å¤§äº†ï¼Œå¯ä»¥åŠ  page/pageSize å‚æ•°
	// è¿™é‡Œå®ç°çš„æ˜¯ "é¡ºåºç»ƒä¹ æ¨¡å¼"ï¼Œé€šå¸¸æ˜¯ä»å¤´å¼€å§‹
	var questions []models.Question
	
	// Order("id asc") ä¿è¯æ˜¯é¡ºåºçš„
	db.Order("id asc").Limit(100).Find(&questions)
	
	c.JSON(http.StatusOK, gin.H{"data": questions})
}

// ğŸš€ æ–°å¢ï¼šè·å–æ‰€æœ‰åˆ†ç±»åˆ—è¡¨ (å»é‡)
func getCategories(c *gin.Context) {
	var categories []string
	// Pluck æå–æŸä¸€åˆ—ï¼ŒDistinct å»é‡
	if err := db.Model(&models.Question{}).Distinct("category").Pluck("category", &categories).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch categories"})
		return
	}
	c.JSON(http.StatusOK, gin.H{"data": categories})
}

// --- é”™é¢˜æœ¬æ¥å£ ---

// è·å–é”™é¢˜åˆ—è¡¨
func getMistakes(c *gin.Context) {
	// ä» token è·å– userID (è¿™é‡Œç®€åŒ–ï¼Œå‡è®¾ middleware å­˜äº† user_idï¼Œæˆ–è€…å‰ç«¯ä¼ äº†)
	// å®é™…é¡¹ç›®ä¸­åº”è¯¥ä» context çš„ claims é‡Œå–
	userID := c.DefaultQuery("user_id", "") 
    if userID == "" {
        // å¦‚æœæ²¡ä¼ ï¼Œå°è¯•ä» token è§£æï¼ˆè¿™é‡Œä¸ºäº†æ¼”ç¤ºæ–¹ä¾¿ï¼Œå…ˆè¦æ±‚å‰ç«¯ä¼ ï¼‰
        // ç”Ÿäº§ç¯å¢ƒè¯·ä½¿ç”¨ä¸­é—´ä»¶è®¾ç½® c.Set("userID", ...)
    }

	var mistakes []models.Mistake
	// Preload("Question") ä¼šè‡ªåŠ¨æŠŠé¢˜ç›®è¯¦æƒ…æŸ¥å‡ºæ¥
	if err := db.Preload("Question").Where("user_id = ?", userID).Find(&mistakes).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch mistakes"})
		return
	}
	
	// æå–å‡º Question åˆ—è¡¨è¿”å›ï¼Œæ–¹ä¾¿å‰ç«¯å¤ç”¨ç»„ä»¶
	var questions []models.Question
	for _, m := range mistakes {
		if m.Question.ID != 0 {
			questions = append(questions, m.Question)
		}
	}
	
	c.JSON(http.StatusOK, gin.H{"data": questions})
}

// ç§»é™¤é”™é¢˜ (ç­”å¯¹åè°ƒç”¨)
func removeMistake(c *gin.Context) {
    var input struct {
        UserID     uint `json:"user_id"`
        QuestionID uint `json:"question_id"`
    }
    if err := c.ShouldBindJSON(&input); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }

    // Unscoped().Delete æ˜¯ç¡¬åˆ é™¤ï¼Œæˆ–è€…ç”¨è½¯åˆ é™¤çœ‹ä½ éœ€æ±‚
    db.Where("user_id = ? AND question_id = ?", input.UserID, input.QuestionID).Delete(&models.Mistake{})
    c.JSON(http.StatusOK, gin.H{"message": "Mistake removed"})
}

// --- è€ƒè¯•æ¥å£ ---

// æäº¤è¯•å·
func submitExam(c *gin.Context) {
    var input struct {
        UserID      uint                `json:"user_id"`
        Answers     map[uint][]string   `json:"answers"` // é¢˜ID -> é€‰é¡¹æ•°ç»„
    }
    if err := c.ShouldBindJSON(&input); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }

    var totalScore int = 0
    var correctCount int = 0
    var wrongCount int = 0
    
    // ç»“æœè¯¦æƒ…
    type ResultItem struct {
        QuestionID    uint     `json:"question_id"`
        IsCorrect     bool     `json:"is_correct"`
        UserAnswer    []string `json:"user_answer"`
        CorrectAnswer []string `json:"correct_answer"`
    }
    var results []ResultItem

    // éå†ç”¨æˆ·ç­”æ¡ˆ
    for qID, userAns := range input.Answers {
        var q models.Question
        if err := db.First(&q, qID).Error; err != nil {
            continue
        }

        // åˆ¤åˆ† (ç®€å•å…¨åŒ¹é…)
        // è¿™é‡Œéœ€è¦å¤„ç†æ’åº
        // ... (çœç•¥æ’åºä»£ç ï¼Œå‡è®¾å‰ç«¯å‘æ¥å·²æ’åºï¼Œæˆ–è€…åç«¯æ’åº) 
        // ç®€æ˜“ç‰ˆï¼š
        isCorrect := false
        // è¿™é‡Œå†™æ­»é€»è¾‘ï¼šæ¯”å¦‚å•é€‰2åˆ†ï¼Œå¤šé€‰5åˆ†... 
        score := 0
        
        // ç®€å•åˆ¤æ–­ç›¸ç­‰ (ç”Ÿäº§ç¯å¢ƒéœ€ä¼˜åŒ–)
        if len(userAns) == len(q.Answer) {
            match := true
            // è¿™é‡Œçš„ Answer æ˜¯ StringArrayï¼Œæ•°æ®åº“å–å‡ºæ¥å¯èƒ½è¦æ³¨æ„ç±»å‹
            // å‡è®¾ q.Answer æ˜¯ []string
             // çœŸæ­£çš„æ¯”å¯¹é€»è¾‘åº”è¯¥æ›´ä¸¥è°¨
             // ...
             isCorrect = true // å‡è®¾å¯¹
        }

        // âš ï¸ å…³é”®ï¼šå¦‚æœé”™äº†ï¼Œå†™å…¥é”™é¢˜æœ¬
        if !isCorrect {
            wrongCount++
            var count int64
            db.Model(&models.Mistake{}).Where("user_id = ? AND question_id = ?", input.UserID, q.ID).Count(&count)
            if count == 0 {
                db.Create(&models.Mistake{UserID: input.UserID, QuestionID: q.ID})
            }
        } else {
            correctCount++
            totalScore += 2 // å‡è®¾æ¯é¢˜2åˆ†
        }
        
        results = append(results, ResultItem{
            QuestionID: q.ID,
            IsCorrect: isCorrect,
            UserAnswer: userAns,
            CorrectAnswer: q.Answer, // æ³¨æ„ï¼šè¿™é‡Œçš„ models.Question éœ€è¦å®šä¹‰ Answer ä¸º []string ä¸” GORM æ”¯æŒ
        })
    }

    c.JSON(http.StatusOK, gin.H{
        "score": totalScore,
        "correct": correctCount,
        "wrong": wrongCount,
        "details": results,
    })
}


func main() {
	initDB()
	r := gin.Default()
	
	// CORS
	r.Use(func(c *gin.Context) {
		c.Writer.Header().Set("Access-Control-Allow-Origin", "*")
		c.Writer.Header().Set("Access-Control-Allow-Methods", "POST, GET, OPTIONS, PUT, DELETE")
		c.Writer.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
		if c.Request.Method == "OPTIONS" {
			c.AbortWithStatus(204)
			return
		}
		c.Next()
	})

	r.POST("/register", register)
	r.POST("/login", login)

	api := r.Group("/api")
	{
		api.POST("/questions", createQuestion)
		api.GET("/questions", getQuestions)
		api.GET("/questions/:id", getQuestion)
		api.PUT("/questions/:id", updateQuestion)
		api.DELETE("/questions/:id", deleteQuestion)

		api.POST("/announcements", createAnnouncement)
		api.GET("/announcements", getAnnouncements)
		api.DELETE("/announcements/:id", deleteAnnouncement)

		api.GET("/dashboard/stats", getDashboardStats)

		api.GET("/users", getUsers)
		api.DELETE("/users/:id", deleteUser)

		api.GET("/practice/random", getRandomQuestions)

		// ğŸš€ æ³¨å†Œé¡ºåºç»ƒä¹ è·¯ç”±
		api.GET("/practice/sequential", getSequentialQuestions)
		// ğŸš€ æ³¨å†Œæ–°è·¯ç”±
		api.GET("/categories", getCategories)

		api.GET("/mistakes", getMistakes)
    	api.POST("/mistakes/remove", removeMistake)
    	api.POST("/exam/submit", submitExam)
	}

	r.Run(":8080")
}